<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fake Earth Sphere</title>
  <style>
    /* Полный экран */
    html, body {
      margin: 0; 
      padding: 0;
      width: 100%; 
      height: 100%;
      overflow: hidden;
      background: black;
    }
    /* Канвас на всю страницу */
    canvas {
      display: block;
      touch-action: none; /* Отключаем скролл при свайпе */
      cursor: grab;
      width: 100%;
      height: 100%;
    }
    canvas:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
<canvas id="sphereCanvas"></canvas>

<script>
  const canvas = document.getElementById("sphereCanvas");
  const ctx    = canvas.getContext("2d");

  function resizeCanvas() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // Параметры "глобуса"
  const baseRadius = 200;  
  const latSteps   = 50;   // Число горизонтальных "полос"
  const lonSteps   = 50;   // Число "долгот"
  
  // Вращение/Анимация
  let angleX      = 0;
  let angleY      = 0;
  let angleZ      = 0;
  let scaleFactor = 1;     // pinch-зум
  let autoRotate  = true;  // лёгкая автопрокрутка

  // Инерция
  let spinVelX = 0;
  let spinVelY = 0;
  const FRICTION = 0.98; // затухание

  // Перетаскивание
  let isDragging    = false;
  let lastX         = 0, lastY = 0;
  let lastPinchDist = 0;

  // Двойной тап — сброс
  let lastTapTime = 0;

  // Генерируем массив точек (широта, долгота)
  let spherePoints = [];
  function generateEarthPoints() {
    spherePoints = [];
    for (let lat = 0; lat <= latSteps; lat++) {
      // phi: от 0 (северный полюс) до PI (южный полюс)
      const phi = (lat / latSteps) * Math.PI;

      for (let lon = 0; lon <= lonSteps; lon++) {
        // theta: от 0 до 2*PI
        const theta = (lon / lonSteps) * 2 * Math.PI;

        const x = baseRadius * Math.sin(phi) * Math.cos(theta);
        const y = baseRadius * Math.sin(phi) * Math.sin(theta);
        const z = baseRadius * Math.cos(phi);

        spherePoints.push({ x, y, z, phi, theta });
      }
    }
  }
  generateEarthPoints();

  // Придумываем “цвет Земли” без текстуры
  // - Белые полюса (phi очень маленький/большой)
  // - “Шум” для континентов/океанов
  function getFakeEarthColor(phi, theta) {
    // Полярные шапки (например, 0.2 радиан ~ 11.5 градусов)
    if (phi < 0.2 || phi > Math.PI - 0.2) {
      return { r: 255, g: 255, b: 255 }; // белый
    }

    // Простая шумовая формула
    // Чем больше значение, тем "вероятнее" суша
    const val = Math.sin(6 * theta) + 0.5 * Math.cos(4 * phi);

    if (val > 0.5) {
      // Пускай будет "пустыня"
      return { r: 210, g: 180, b: 140 }; // tan
    } else if (val > 0) {
      // Леса
      return { r: 34, g: 139, b: 34 }; // forestgreen
    } else {
      // Океан
      return { r: 0, g: 105, b: 148 }; // deep ocean
    }
  }

  // Матрицы вращения
  function matrixMultiply(m, v) {
    return {
      x: m[0][0]*v.x + m[0][1]*v.y + m[0][2]*v.z,
      y: m[1][0]*v.x + m[1][1]*v.y + m[1][2]*v.z,
      z: m[2][0]*v.x + m[2][1]*v.y + m[2][2]*v.z
    };
  }
  function rotateX(a) {
    return [
      [1, 0, 0],
      [0,  Math.cos(a), -Math.sin(a)],
      [0,  Math.sin(a),  Math.cos(a)]
    ];
  }
  function rotateY(a) {
    return [
      [ Math.cos(a), 0, Math.sin(a)],
      [ 0, 1, 0],
      [-Math.sin(a), 0, Math.cos(a)]
    ];
  }
  function rotateZ(a) {
    return [
      [ Math.cos(a), -Math.sin(a), 0],
      [ Math.sin(a),  Math.cos(a), 0],
      [ 0, 0, 1]
    ];
  }
  function applyScale(v, s) {
    return { x: v.x*s, y: v.y*s, z: v.z*s };
  }

  // ----- Управление мышью -----
  canvas.addEventListener("mousedown", (e) => {
    startDrag(e.clientX, e.clientY);
  });
  canvas.addEventListener("mousemove", (e) => {
    if (isDragging) moveDrag(e.clientX, e.clientY);
  });
  canvas.addEventListener("mouseup", endDrag);
  canvas.addEventListener("mouseleave", endDrag);

  // ----- Управление на сенсоре (touch) -----
  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      // Проверка на двойной тап
      const now = Date.now();
      if (now - lastTapTime < 300) {
        resetSphere();
      }
      lastTapTime = now;
      const t = e.touches[0];
      startDrag(t.clientX, t.clientY);
    } else if (e.touches.length === 2) {
      // Pinch (зум)
      lastPinchDist = getTouchDistance(e.touches[0], e.touches[1]);
      autoRotate = false;
    }
    e.preventDefault();
  }, {passive: false});

  canvas.addEventListener("touchmove", (e) => {
    if (e.touches.length === 1 && isDragging) {
      const t = e.touches[0];
      moveDrag(t.clientX, t.clientY);
    } else if (e.touches.length === 2) {
      // Двумя пальцами — pinch
      const dist = getTouchDistance(e.touches[0], e.touches[1]);
      if (lastPinchDist > 0) {
        scaleFactor *= (dist / lastPinchDist);
        if (scaleFactor < 0.2) scaleFactor = 0.2;
        if (scaleFactor > 5)   scaleFactor = 5;
      }
      lastPinchDist = dist;
    }
    e.preventDefault();
  }, {passive: false});

  canvas.addEventListener("touchend", (e) => {
    if (e.touches.length < 2) {
      endDrag();
    }
    e.preventDefault();
  }, {passive: false});

  // ----- Вспомогательные функции -----
  function startDrag(x, y) {
    isDragging = true;
    autoRotate = false;
    spinVelX   = 0;
    spinVelY   = 0;
    lastX      = x;
    lastY      = y;
  }
  function moveDrag(x, y) {
    const dx = x - lastX;
    const dy = y - lastY;
    angleY += dx * 0.01;
    angleX += dy * 0.01;
    spinVelX = dy * 0.01;
    spinVelY = dx * 0.01;
    lastX = x;
    lastY = y;
  }
  function endDrag() {
    isDragging = false;
    lastPinchDist = 0;
  }
  function getTouchDistance(t1, t2) {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }
  // Сброс (двойной тап)
  function resetSphere() {
    angleX = 0; angleY = 0; angleZ = 0;
    scaleFactor = 1;
    spinVelX = 0; spinVelY = 0;
    autoRotate = true;
  }

  // ----- Основной цикл рисования -----
  requestAnimationFrame(draw);
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Если шар не крутят, включаем либо авто-поворот, либо инерцию
    if (!isDragging) {
      if (Math.abs(spinVelX) < 0.0001 && Math.abs(spinVelY) < 0.0001) {
        // Автоповорот
        if (autoRotate) {
          angleX += 0.0007;
          angleY += 0.001;
          angleZ += 0.0007;
        }
      } else {
        // Инерция
        angleX += spinVelX;
        angleY += spinVelY;
        spinVelX *= FRICTION;
        spinVelY *= FRICTION;
      }
    }

    // Собираем матрицы
    const rx = rotateX(angleX);
    const ry = rotateY(angleY);
    const rz = rotateZ(angleZ);

    // Рисуем все точки
    for (const p of spherePoints) {
      // Повернём
      let rotated = matrixMultiply(rx, p);
      rotated     = matrixMultiply(ry, rotated);
      rotated     = matrixMultiply(rz, rotated);
      // Масштаб
      rotated     = applyScale(rotated, scaleFactor);

      const x2d = rotated.x + canvas.width / 2;
      const y2d = rotated.y + canvas.height / 2;

      // Простейшее "освещение": ближняя сторона чуть светлее
      const light = Math.max(0, -rotated.z / (baseRadius * scaleFactor));

      // Получаем цвет (океан, суша, полюса) по широте/долготе
      const {r, g, b} = getFakeEarthColor(p.phi, p.theta);

      // Притемняем “теневую” сторону
      const R = Math.floor(r * (0.6 + 0.4 * light));
      const G = Math.floor(g * (0.6 + 0.4 * light));
      const B = Math.floor(b * (0.6 + 0.4 * light));

      ctx.fillStyle = `rgb(${R},${G},${B})`;
      // Ставим крошечный пиксель
      ctx.fillRect(x2d, y2d, 2, 2);
    }

    requestAnimationFrame(draw);
  }
</script>
</body>
</html>
