<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Beautiful 3D Sphere</title>
  <style>
    /* Растягиваем на весь экран */
    html, body {
      margin: 0; padding: 0; 
      width: 100%; height: 100%; 
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none; /* Отключаем скролл на мобилках */
      cursor: grab;
    }
    canvas:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>

<canvas id="sphereCanvas"></canvas>

<script>
  const canvas = document.getElementById("sphereCanvas");
  const ctx = canvas.getContext("2d");

  // Подгоняем canvas под окно
  function resizeCanvas() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  // Параметры
  const numPoints   = 1000;
  const baseRadius  = 200;
  const focalLength = 400; // “фокус” для перспективы

  // Точка отсчёта (центр экрана)
  function centerX() { return canvas.width / 2; }
  function centerY() { return canvas.height / 2; }

  // Генерация случайных точек на сфере + хранение θ для цвета
  function generateSpherePoints(n, r) {
    const points = [];
    for (let i = 0; i < n; i++) {
      const theta = Math.random() * 2 * Math.PI;
      const phi   = Math.acos(Math.random() * 2 - 1);
      const x     = r * Math.sin(phi) * Math.cos(theta);
      const y     = r * Math.sin(phi) * Math.sin(theta);
      const z     = r * Math.cos(phi);
      points.push({ x, y, z, theta });
    }
    return points;
  }
  const spherePoints = generateSpherePoints(numPoints, baseRadius);

  // Вспомогательные матрицы
  function matrixMultiply(m, v) {
    return {
      x: m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
      y: m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
      z: m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z
    };
  }
  function rotateX(a) {
    return [
      [1, 0, 0],
      [0,  Math.cos(a), -Math.sin(a)],
      [0,  Math.sin(a),  Math.cos(a)]
    ];
  }
  function rotateY(a) {
    return [
      [ Math.cos(a), 0, Math.sin(a)],
      [ 0, 1, 0],
      [-Math.sin(a), 0, Math.cos(a)]
    ];
  }
  function rotateZ(a) {
    return [
      [ Math.cos(a), -Math.sin(a), 0],
      [ Math.sin(a),  Math.cos(a), 0],
      [ 0, 0, 1]
    ];
  }
  // Масштаб (для pinch-зум)
  function applyScale(v, s) {
    return { x: v.x*s, y: v.y*s, z: v.z*s };
  }

  // Перспектива: ближние точки крупнее, дальние – меньше
  function perspectiveProject(v) {
    // Если объект за "камерой", фактор может стать отрицательным,
    // поэтому проверим (focalLength - v.z)
    const dist = (focalLength - v.z);
    if (dist <= 0.1) {
      // Слишком за камерой — сделаем видимым, но может “улетать” за экран
      return { x: v.x, y: v.y, scale: 10 }; 
    }
    const factor = focalLength / dist;
    return {
      x: v.x * factor, 
      y: v.y * factor,
      scale: factor
    };
  }

  // ----- Параметры анимации -----
  let angleX = 0, angleY = 0, angleZ = 0;
  let scaleFactor = 1;
  let animOffset  = 0;  // чтобы “радужно” перекрашивались
  let autoRotate  = true;

  // ----- Инерция -----
  let spinVelX = 0;
  let spinVelY = 0;
  const FRICTION = 0.98;

  // ----- Drag / Touch -----
  let isDragging   = false;
  let lastX = 0, lastY = 0;
  let lastPinchDist = 0;

  // ----- Двойной тап -----
  let lastTapTime = 0;

  // События мыши
  canvas.addEventListener("mousedown", (e) => {
    startDrag(e.clientX, e.clientY);
  });
  canvas.addEventListener("mousemove", (e) => {
    if (isDragging) moveDrag(e.clientX, e.clientY);
  });
  canvas.addEventListener("mouseup", endDrag);
  canvas.addEventListener("mouseleave", endDrag);

  // События тача
  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      // Проверяем на двойной тап
      const now = Date.now();
      if (now - lastTapTime < 300) {
        resetSphere();
      }
      lastTapTime = now;
      const t = e.touches[0];
      startDrag(t.clientX, t.clientY);
    } else if (e.touches.length === 2) {
      // Начинаем pinch
      lastPinchDist = getTouchDistance(e.touches[0], e.touches[1]);
      autoRotate = false;
    }
    e.preventDefault();
  }, {passive: false});

  canvas.addEventListener("touchmove", (e) => {
    if (e.touches.length === 1 && isDragging) {
      const t = e.touches[0];
      moveDrag(t.clientX, t.clientY);
    } else if (e.touches.length === 2) {
      // pinch
      const dist = getTouchDistance(e.touches[0], e.touches[1]);
      if (lastPinchDist > 0) {
        const factor = dist / lastPinchDist;
        scaleFactor *= factor;
        // Немного ограничим
        if (scaleFactor < 0.2) scaleFactor = 0.2;
        if (scaleFactor > 5)   scaleFactor = 5;
      }
      lastPinchDist = dist;
    }
    e.preventDefault();
  }, {passive: false});

  canvas.addEventListener("touchend", (e) => {
    if (e.touches.length < 2) endDrag();
    e.preventDefault();
  }, {passive: false});

  // Подсчёт расстояния между двумя пальцами (pinch)
  function getTouchDistance(t1, t2) {
    const dx = t2.clientX - t1.clientX;
    const dy = t2.clientY - t1.clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  // --------- Drag / Инструменты ----------
  function startDrag(x, y) {
    isDragging = true;
    autoRotate = false; 
    spinVelX   = 0;
    spinVelY   = 0;
    lastX      = x;
    lastY      = y;
  }
  function moveDrag(x, y) {
    const dx = x - lastX;
    const dy = y - lastY;
    angleY += dx * 0.01;
    angleX += dy * 0.01;
    // Запоминаем скорость для инерции
    spinVelX = dy * 0.01;
    spinVelY = dx * 0.01;
    lastX = x;
    lastY = y;
  }
  function endDrag() {
    isDragging = false;
    lastPinchDist = 0;
  }
  // Сброс по двойному тапу
  function resetSphere() {
    angleX = 0; angleY = 0; angleZ = 0;
    scaleFactor = 1;
    spinVelX = 0; spinVelY = 0;
    autoRotate = true;
  }

  // --------- Анимация ---------
  function draw() {
    // Вместо полного очистки оставляем "след"
    // Чем меньше alpha, тем более “длинный шлейф”
    ctx.fillStyle = "rgba(0, 0, 0, 0.08)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (!isDragging) {
      // Инерция или autoRotate
      if (Math.abs(spinVelX) < 0.0001 && Math.abs(spinVelY) < 0.0001) {
        // Если нет инерции, то вращаем слегка сами
        if (autoRotate) {
          angleX += 0.0007;
          angleY += 0.001;
          angleZ += 0.0007;
        }
      } else {
        // Инерция
        angleX += spinVelX;
        angleY += spinVelY;
        spinVelX *= FRICTION;
        spinVelY *= FRICTION;
      }
    }

    // Матрицы вращения
    const rx = rotateX(angleX);
    const ry = rotateY(angleY);
    const rz = rotateZ(angleZ);

    // Рисуем все точки
    for (const p of spherePoints) {
      // Повороты
      let rotated = matrixMultiply(rx, p);
      rotated     = matrixMultiply(ry, rotated);
      rotated     = matrixMultiply(rz, rotated);
      // Pinch-зум
      rotated     = applyScale(rotated, scaleFactor);
      // Перспектива
      const proj  = perspectiveProject(rotated);

      const x2d = centerX() + proj.x;
      const y2d = centerY() + proj.y;

      // Простейший "свет": дальние точки чуть темнее
      // Хотя у нас есть hsl, сделаем яркость зависящей от z
      const light = Math.max(0, -rotated.z / (baseRadius * scaleFactor));

      // Цвет точки
      const hue = ((p.theta / (2 * Math.PI)) * 360 + animOffset) % 360;
      const saturation = 100;
      const lum = 40 + 40 * light; 
      ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lum}%)`;

      // Радиус точки растёт с "scale"
      // proj.scale = перспективное уменьшение/увеличение
      const r = 2 * proj.scale * 0.01; // подбирай на вкус
      ctx.beginPath();
      ctx.arc(x2d, y2d, r, 0, 2 * Math.PI);
      ctx.fill();
    }

    animOffset += 1;
    requestAnimationFrame(draw);
  }

  draw();
</script>
</body>
</html>
